## implementation of standard EMOS model 
## here: alldata version with training 2007-2015,
## but: use window of surrounding days ("climatological window")
## based on prepared Rdata file

## NOTE: only makes sense as alldata variant

## --------------- data preparation --------------- ##

rm(list=ls())

data_dir <- "/media/sebastian/Elements/Postproc_NN/data/"
load(paste0(data_dir, "data_all.Rdata"))

# renove all covariates (not used in standard EMOS)
# data[, !(names(data) %in% c("obs", "date", "station", "t2m_mean", "t2m_var"))] <- NULL # does not work on cluster?
data <- data[, -which(!(names(data) %in% c("obs", "date", "station", "t2m_mean", "t2m_var")))]
head(data)

library(scoringRules)
library(lubridate)

## --------------- Helper functions for optimization --------------- ##

# objective function for minimum CRPS estimation of parameters
#   we fit an EMOS model N(mu, sigma), where
#   the mean value mu = a + b * ensmean, and
#   the variance sigma^2 = c + d * ensvar
#   a,b,c,d are determined by minimizing the mean CRPS over a
#   training set of past forecasts and observations
objective_fun <- function(par, ensmean, ensvar, obs){
  m <- cbind(1, ensmean) %*% par[1:2]
  ssq_tmp <- cbind(1, ensvar) %*% par[3:4]
  if(any(ssq_tmp < 0)){
    return(999999)
  } else{
    s <- sqrt(ssq_tmp)
    return(sum(crps_norm(y = obs, location = m, scale = s)))
  }
}

# gradient of objective function to use in optim()
#   including the gradient of the CRPS (as function of a,b,c,d)
#   allows faster numerical optmization as the gradient does
#   not need to be determined numerically
gradfun_wrapper <- function(par, obs, ensmean, ensvar){
  loc <- cbind(1, ensmean) %*% par[1:2]
  sc <- sqrt(cbind(1, ensvar) %*% par[3:4])
  dcrps_dtheta <- gradcrps_norm(y = obs, location = loc, scale = sc) 
  out1 <- dcrps_dtheta[,1] %*% cbind(1, ensmean)
  out2 <- dcrps_dtheta[,2] %*% 
    cbind(1/(2*sqrt(par[3]+par[4]*ensvar)), 
          ensvar/(2*sqrt(par[3]+par[4]*ensvar)))
  return(as.numeric(cbind(out1,out2)))
}


## --------------- post-processing function --------------- ##

## main postprocessing function for a global EMOS 
# i.e., using all available stations for training. Argiments:
## input:
# vdate = validdate for which EMOS coefficients should be determined (should be from dates vector)
#         by the function
#         for 00 UTC forecasts, only past 00 UTC fc cases are used, similarly for 12 UTC
# window_width_half:
##    Training dates will be:
##    current day in all previous years & window_width_half days before and after that
##    length this is 1 + 2*window_width_half
## output: vector of coefficients a,b,c,d to be used at vdate

postproc_global <- function(vdate, window_width_half){
  
  # determine training set
  ##
  ## this is changed for climatological window version
  ##
  # deal with February 29 existing only all 4 years (set to Feb 28)
  if(month(vdate) == 2){
    if(day(vdate) == 29){
      vdate <- vdate - days(1)
    }
  }
  
  vdate_prevyears <- vdate - years(1:10)
  if(any(vdate_prevyears < data$date[1])){
    vdate_prevyears[which(vdate_prevyears < data$date[1])] <- NULL
  }
  
  train_dates <- vdate_prevyears
  for(yy in 1:length(vdate_prevyears)){
    today <- vdate_prevyears[yy]
    train_dates <- c(train_dates, today - days(1:window_width_half))
    train_dates <- c(train_dates, today + days(1:window_width_half))
  }
  
  data_train <- data[which(is.element(as.Date(data$date), as.Date(train_dates))), ]
  
  # remove incomplete cases (= NA obs or fc)
  data_train <- data_train[complete.cases(data_train), ]
  
  # determine optimal EMOS coefficients a,b,c,d using minimum CRPS estimation
  optim_out <- optim(par = c(1,1,1,1), 
                     fn = objective_fun,
                     gr = gradfun_wrapper,
                     ensmean = data_train$t2m_mean, 
                     ensvar = data_train$t2m_var, 
                     obs = data_train$obs,
                     method = "BFGS")
  
  # check convergence of the numerical optimization
  if(optim_out$convergence != 0){
    message("numerical optimization did not converge")
  }
  
  # return optimal parameters
  return(optim_out$par)
}


# all days in 2016
eval_start <- as.Date("2016-01-01 00:00 UTC")
eval_end <- as.Date("2016-12-31 00:00 UTC")
eval_dates <- seq(eval_start, eval_end, by = "1 day")

m <- 5
crps_pp <- NULL

data_eval_all <- subset(data, date >= eval_start & date <= eval_end)

for(day_id in 1:length(eval_dates)){
  
  today <- eval_dates[day_id]
  
  # progress indicator
  if(day(as.Date(today)) == 1){
    cat("Starting at", paste(Sys.time()), ":", as.character(today), "\n"); flush(stdout())
  }
  
  # post-processing
  par_out <- postproc_global(vdate = today, window_width_half = m)
  
  # out of sample distribution parameters for today
  data_eval <- subset(data, date == today)
  loc <- c(cbind(1, data_eval$t2m_mean) %*% par_out[1:2])
  scsquared_tmp <- c(cbind(1, data_eval$t2m_var) %*% par_out[3:4])
  if(any(scsquared_tmp <= 0)){
    print("negative scale, taking absolute value")
    sc <- sqrt(abs(scsquared_tmp))
  } else{
    sc <- sqrt(scsquared_tmp)
  }
  
  # CRPS computation
  crps_today <- crps_norm(y = data_eval$obs, mean = loc, sd = sc)
  crps_pp[which(data_eval_all$date == today)] <- crps_today
}

summary(crps_pp)
#     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
#   0.295   0.464   0.672   1.008   1.203  18.375   14324 